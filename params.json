{"name":"Ranola","tagline":"Randomized Numerical Linear Algebra for Scala","body":"# ranola\r\n\r\n[![Build Status](https://travis-ci.org/nikdon/ranola.svg?branch=master)](https://travis-ci.org/nikdon/ranola)\r\n[![Codacy Badge](https://www.codacy.com/project/badge/134576e1957c4cd8a8cf1755bd839e71)](https://www.codacy.com/app/nd/ranola)\r\n[ ![Download](https://api.bintray.com/packages/nikdon/ranola/ranola/images/download.svg) ](https://bintray.com/nikdon/ranola/ranola/_latestVersion)\r\n\r\n**ranola** is a library for low-rank matrix approximations by randomized algorithms (Randomized Numerical Linear Algebra aka RandNLA). Compared with standard deterministic algorithms, the randomized methods are often faster and produce accurate results. Empirical results show that a corresponding implementation can be faster than LAPACK on dense matrices.\r\n\r\nAt the moment the simplest direct scheme is implemented. It allows to ensure a minimal error in the final approximation of decompositions:\r\n\r\n- Singular value decomposition\r\n- Eigen value decomposition\r\n\r\n##  Randomized schemes\r\n\r\n1. Generic scheme ([§4.1][1]) is designed for solving the fixed-rank problem, where the target rank of the input matrix is specified in advance. This algorithm works well for matrices whose singular values exhibit some decay, but they may produce a poor basis when the input matrix has a flat singular spectrum or when the input matrix is very large.\r\n\r\n      ```scala\r\n      val EigSym(lambda, evs) = EVDR.generic(A_dense, k = 3, nOverSamples = 2)\r\n      \r\n      val SVD(ur, sr, vr) = SVDR.generic(M, k = 3, nOverSamples = 10)\r\n      ```\r\n    \r\n2. Adaptive scheme ([§4.2][1]) can handle the fixed-precision problem with predifined computational tolerance. The CPU time requirements of schemes 1 and 2 are essentially identical.\r\n\r\n      ```scala\r\n      not implemented in v 0.2.0\r\n      ```\r\n\r\n3. Power Iteration scheme ([§4.3][1]) requires ```2*nIter + 1``` times as many matrix–vector multiplies as scheme 1, but is far more accurate in situations where the singular values of matrix to decompose decay slowly. Scheme 3 targets the fixed-rank problem. In situations where it is critical to achieve nearoptimal approximation errors, one can increase the oversampling beyond standard recommendation ```overSamples = 5``` all the way to ```overSamples = k``` without changing the scaling of the asymptotic computational cost. This procedure is vulnerable to round-off errors. The recommended implementation appears as scheme 4.\r\n\r\n      ```scala\r\n      val SVD(ur, sr, vr) = SVDR.viaPowerIteration(M, k = 3, nIter = 5, nOverSamples = 2)\r\n      \r\n      val EigSym(lambda, evs) = EVDR.viaPowerIteration(M, k = 3, nIter = 5, nOverSamples = 2)\r\n      ```\r\n\r\n4. Subspace Iteration scheme ([§4.4][1]) is designed for solving the fixed-rank problem, where the target rank of the input matrix is specified in advance. This procedure is invulnerable to round-off errors in opposite to Power Iteration algorithm ([§4.3][1]).\r\n\r\n      ```scala\r\n      val SVD(ur, sr, vr) = SVDR.viaSubspaceIterations(M, k = 3, nIter = 5, nOverSamples = 2)\r\n      \r\n      val EigSym(lambda, evs) = EVDR.viaSubspaceIterations(M, k = 3, nIter = 5, nOverSamples = 2)\r\n      ```\r\n\r\n5. Fast Generic scheme ([§4.5][1]) uses subsampled random Fourier transform (SRFT) that can be used to identify a nearoptimal basis for a rank-k matrix using l = (k + log(M.cols)) log(k) samples (```overSamples = (k + log(M.cols)) log(k) - k```). In practice, setting ```overSamples = 10``` or ```overSamples = 20``` is typically more than adequate. It allows to compute an approximate rank-(l) factorization of a general dense m-by-n matrix in roughly O(mn log(k + overSamples)) flops.\r\n\r\n      ```\r\n      not implemented in v 0.2.0\r\n      ```\r\n\r\n## Number of oversamples\r\n\r\nNumber of oversamples depends on:\r\n\r\n- **Matrix dimensions**. Very large matrices may require more oversampling.\r\n\r\n- **Singular spectrum**. The more rapid the decay of the singular values, the less oversampling is needed. In the extreme case that the matrix has exact rank **k**, it is not necessary to oversample.\r\n\r\n- **Random test matrix**. Gaussian matrices succeed with very little oversampling, such as ```overSamples = 5``` or ```overSamples = 10```. There is rarely any advantage to select **overSamples** > **k**.\r\n\r\n[1]: http://arxiv.org/pdf/0909.4061\r\n","google":"UA-66842015-1","note":"Don't delete this file! It's used internally to help with page regeneration."}